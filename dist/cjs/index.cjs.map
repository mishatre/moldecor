{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/utils/helpers.ts", "../../src/utils/metadata.ts", "../../src/service/ext/channel.ts", "../../src/service/action.ts", "../../src/service/event.ts", "../../src/service/method.ts", "../../src/service/service.ts"],
  "sourcesContent": ["// @public\nexport { Channel } from './service/ext/channel.js';\n\n// @public\nexport { Action } from './service/action.js';\n// @public\nexport { Event, Created, Started, Stopped } from './service/event.js';\n// @public\nexport { Method } from './service/method.js';\n// @public\nexport { Service } from './service/service.js';\n", "export function cleanRoutePath(str: string): string {\n    return str.replace(/[^a-zA-Z0-9-/]/g, '');\n}\n\nexport function deepClone<T extends any>(obj: T): T {\n    if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }\n\n    if (obj instanceof Date) {\n        return new Date(obj.getTime()) as T;\n    }\n\n    if (obj instanceof Set) {\n        const clonedSet = new Set();\n        obj.forEach((value) => clonedSet.add(deepClone(value)));\n        return clonedSet as T;\n    }\n\n    if (obj instanceof Map) {\n        const clonedMap = new Map();\n        obj.forEach((value, key) => clonedMap.set(key, deepClone(value)));\n        return clonedMap as T;\n    }\n\n    if (obj instanceof RegExp) {\n        return new RegExp(obj.source, obj.flags) as T;\n    }\n\n    const clone = Array.isArray(obj) ? [] : {};\n    // @ts-expect-error\n    Object.entries(obj).forEach(([key, value]) => (clone[key] = deepClone(value)));\n\n    return clone as T;\n}\n", "import 'reflect-metadata';\n\nimport { deepClone } from './helpers.js';\n\nexport const META_PREFIX: string = 'moleculer:decorators';\n\nfunction isKey(key: string, scope: string = '') {\n    return typeof key === 'string' && key.startsWith(`${META_PREFIX}${scope}:`);\n}\n\nfunction prefixKey(key: string, scope: string = '') {\n    if (!isKey(key, scope)) {\n        return `${META_PREFIX}${scope}:${key}`;\n    }\n\n    return key;\n}\n\nexport function getMetadataKeys(target: any, scope: string = '') {\n    const keys = Reflect.getMetadataKeys(target) || [];\n\n    const metadataKeys: { key: string; metadata: any }[] = [];\n    keys.forEach((key) => {\n        if (isKey(key, scope)) {\n            metadataKeys.push({\n                key: key.replace(new RegExp(`^${META_PREFIX}${scope}:`), ''),\n                metadata: getMetadata(target, key, scope),\n            });\n        }\n    });\n\n    return metadataKeys;\n}\n\nexport function getMetadata(target: any, key: string, scope: string = '') {\n    return deepClone(Reflect.getMetadata(prefixKey(key, scope), target));\n}\n\nexport function setMetadata(target: any, key: string, value: any, scope: string = '') {\n    Reflect.defineMetadata(prefixKey(key, scope), value, target);\n}\n\nexport function removeMetadata(target: any, key: string, scope: string = '') {\n    return Reflect.deleteMetadata(prefixKey(key, scope), target);\n}\n\nexport function getOwnMetadata(target: any, key: string, scope: string = '') {\n    return deepClone(Reflect.getOwnMetadata(prefixKey(key, scope), target));\n}\n\nexport function setCache(target: any, key: string, value: any) {\n    setMetadata(target, key, value, 'cache');\n}\n\nexport function getCache(target: any, key: string) {\n    return getMetadata(target, key, 'cache');\n}\n\nexport function getTypes(target: any, key: string | symbol) {\n    return Reflect.getMetadata('design:type', target, key);\n}\n", "import { getMetadata, setMetadata } from '../../utils/index.js';\n\nexport type ChanneltOptions = Partial<Exclude<any, 'handler'>> & { name: string };\n\nexport function Channel(options?: ChanneltOptions): MethodDecorator {\n    return <T>(\n        target: Object,\n        propertyKey: string | symbol,\n        descriptor: TypedPropertyDescriptor<T>,\n    ) => {\n        const handler = descriptor.value;\n\n        if (!handler || typeof handler !== 'function') {\n            throw new TypeError('An event handler must be a function');\n        }\n\n        const name = propertyKey.toString();\n        const channels = getMetadata(target, 'channels', 'service') || {};\n\n        channels[name] = Object.assign({}, { handler, name }, options);\n\n        setMetadata(target, 'channels', channels, 'service');\n        return descriptor;\n    };\n}\n", "import { ActionSchema, Context } from 'moleculer';\n\nimport { PartialRequired, getMetadata, setMetadata } from '../utils/index.js';\n\nexport type ActionOptions = PartialRequired<Exclude<ActionSchema, 'handler'>, 'name'>;\n\ntype MethodDecorator<T> = (\n    target: Object,\n    propertyKey: string | symbol,\n    descriptor: TypedPropertyDescriptor<T>,\n) => TypedPropertyDescriptor<T> | void;\n\nexport function Action<P = {}, T = (ctx: Context<P>) => void>(\n    options?: ActionOptions,\n): MethodDecorator<T> {\n    return (target, propertyKey, descriptor) => {\n        const handler = descriptor.value;\n\n        if (!handler || typeof handler !== 'function') {\n            throw new TypeError('An action must be a function');\n        }\n\n        const name = propertyKey.toString();\n        const actions = getMetadata(target, 'actions', 'service') || {};\n        actions[name] = Object.assign({}, { handler, name, visibility: 'public' }, options);\n\n        setMetadata(target, 'actions', actions, 'service');\n        return descriptor;\n    };\n}\n", "import { EventSchema } from 'moleculer';\n\nimport { PartialRequired, getMetadata, setMetadata } from '../utils/index.js';\n\nexport type EventOptions = PartialRequired<Exclude<EventSchema, 'handler'>, 'name'>;\n\nexport type LifeCycleEventNames = 'created' | 'started' | 'stopped';\n\n// @public\nexport function Event(options?: EventSchema): MethodDecorator {\n    return <T>(\n        target: Object,\n        propertyKey: string | symbol,\n        descriptor: TypedPropertyDescriptor<T>,\n    ) => {\n        const handler = descriptor.value;\n\n        if (!handler || typeof handler !== 'function') {\n            throw new TypeError('An event handler must be a function');\n        }\n\n        const name = propertyKey.toString();\n        const events = getMetadata(target, 'events', 'service') || {};\n\n        events[name] = Object.assign({}, { handler, name }, options);\n\n        setMetadata(target, 'events', events, 'service');\n        return descriptor;\n    };\n}\n\nexport function createLifeCycleEvent(name: LifeCycleEventNames): MethodDecorator {\n    if (!name) {\n        throw new ReferenceError('Lifecycle event name required');\n    }\n\n    return <T>(\n        target: Object,\n        _propertyKey: string | symbol,\n        descriptor: TypedPropertyDescriptor<T>,\n    ) => {\n        const handler = descriptor.value;\n\n        if (!handler || typeof handler !== 'function') {\n            throw new TypeError('An lifecycle event handler must be a function');\n        }\n\n        setMetadata(target, name, handler, 'service');\n        return descriptor;\n    };\n}\n\n// @public\nexport const Created = createLifeCycleEvent('created') as MethodDecorator;\n// @public\nexport const Started = createLifeCycleEvent('started') as MethodDecorator;\n// @public\nexport const Stopped = createLifeCycleEvent('stopped') as MethodDecorator;\n", "import { getMetadata, setMetadata } from '../utils/index.js';\n\nconst MoleculerMethod = <T>(\n    target: Object,\n    propertyKey: string | symbol,\n    descriptor: TypedPropertyDescriptor<T>,\n) => {\n    const handler = descriptor.value;\n\n    if (!handler || typeof handler !== 'function') {\n        throw new TypeError('A method must be a function');\n    }\n\n    const name = propertyKey.toString();\n    const methods = getMetadata(target, 'methods', 'service') || {};\n    methods[name] = { handler };\n\n    setMetadata(target, 'methods', methods, 'service');\n    return descriptor;\n};\n\n// @public\nexport const Method = MoleculerMethod as MethodDecorator;\n", "import {\n    Service as MoleculerService,\n    ServiceHooks,\n    ServiceSchema,\n    ServiceSettingSchema,\n} from 'moleculer';\n\nimport { getMetadata, getMetadataKeys, setMetadata } from '../utils/index.js';\n\n/* -------------------------------------------- types ------------------------------------------- */\n\nexport interface ServiceDependency {\n    name: string;\n    version?: string | number;\n}\n\nexport interface ServiceOptions<S> {\n    name?: string;\n    version?: string | number;\n    settings?: S & ServiceSettingSchema;\n    dependencies?: string | ServiceDependency | Array<string | ServiceDependency>;\n    metadata?: any;\n    mixins?: Array<Partial<ServiceSchema> | ServiceConstructor<any>>;\n    hooks?: ServiceHooks;\n\n    [name: string]: any;\n}\n\nexport interface ServiceConstructor<S> {\n    new (...args: any[]): MoleculerService<S>;\n}\n\nexport type ServiceDecorator = <S, T extends ServiceConstructor<S>>(constructor: T) => T;\n\n/* ------------------------------------------- methods ------------------------------------------ */\n\nexport function isServiceClass<S>(constructor: any): constructor is ServiceConstructor<S> {\n    return typeof constructor === 'function' && MoleculerService.isPrototypeOf(constructor);\n}\n\nexport function getServiceInnerSchema<S>(\n    constructor: ServiceConstructor<S>,\n): Partial<ServiceSchema<S>> {\n    if (!isServiceClass(constructor)) {\n        throw TypeError('Class must extend Service');\n    }\n\n    const serviceSchema: Partial<ServiceSchema<S>> = {};\n\n    const keys = getMetadataKeys(constructor.prototype, 'service');\n    keys.forEach(({ key, metadata }) => (serviceSchema[key] = metadata));\n\n    return serviceSchema;\n}\n\nexport function getServiceSchema<S>(constructor: ServiceConstructor<S>): ServiceSchema<S> {\n    if (!isServiceClass(constructor)) {\n        throw TypeError('Class must extend Service');\n    }\n\n    return (\n        getMetadata(constructor.prototype, 'schema', 'service') ||\n        getServiceInnerSchema(constructor)\n    );\n}\n\nexport function convertServiceMixins<S>(schema: ServiceSchema<S>) {\n    if (!schema.mixins) return;\n\n    const convertMixins = <S>(mixins: Array<Partial<ServiceSchema<S>> | ServiceConstructor<S>>) => {\n        return mixins.map((mixin) => {\n            const convertedMixin = isServiceClass<S>(mixin) ? getServiceSchema<S>(mixin) : mixin;\n            if (convertedMixin.mixins) {\n                convertedMixin.mixins = convertMixins(convertedMixin.mixins);\n            }\n            return convertedMixin;\n        });\n    };\n\n    schema.mixins = convertMixins(schema.mixins);\n}\n\ntype InstanceGenericType<T extends abstract new (...args: any) => MoleculerService<any>> =\n    T extends abstract new (...args: any) => MoleculerService<infer R> ? R : any;\n\n// @public\nexport function Service<T extends ServiceConstructor<any>, S extends InstanceGenericType<T>>(\n    options: ServiceOptions<S> = {},\n) {\n    return (constructor: T): T => {\n        if (!isServiceClass<S>(constructor)) {\n            throw TypeError('Class must extend Service');\n        }\n\n        let schema: ServiceSchema<S> = getMetadata(constructor.prototype, 'schema', 'service');\n\n        if (!schema) {\n            // prepare defaults\n            const defaults = {\n                name: constructor.name,\n                ...options,\n            };\n\n            // get schema\n            schema = {\n                ...defaults,\n                ...getServiceInnerSchema(constructor),\n            };\n\n            // convert mixins\n            convertServiceMixins(schema);\n\n            setMetadata(constructor.prototype, 'schema', schema, 'service');\n        }\n\n        return class extends constructor {\n            constructor(...args: any[]) {\n                super(...args);\n                this.parseServiceSchema(schema);\n            }\n        };\n    };\n}\n"],
  "mappings": "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",
  "names": ["MoleculerService"]
}
