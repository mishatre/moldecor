{
  "version": 3,
  "sources": ["../src/utils/helpers.ts", "../src/utils/metadata.ts", "../src/service/action.ts", "../src/service/event.ts", "../src/service/method.ts", "../src/service/service.ts", "../src/service/ext/channel.ts"],
  "sourcesContent": ["export function cleanRoutePath(str: string): string {\n    return str.replace(/[^a-zA-Z0-9-/]/g, '');\n}\n\nexport function deepClone<T extends any>(obj: T): T {\n    if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }\n\n    if (obj instanceof Date) {\n        return new Date(obj.getTime()) as T;\n    }\n\n    if (obj instanceof Set) {\n        const clonedSet = new Set();\n        obj.forEach((value) => clonedSet.add(deepClone(value)));\n        return clonedSet as T;\n    }\n\n    if (obj instanceof Map) {\n        const clonedMap = new Map();\n        obj.forEach((value, key) => clonedMap.set(key, deepClone(value)));\n        return clonedMap as T;\n    }\n\n    if (obj instanceof RegExp) {\n        return new RegExp(obj.source, obj.flags) as T;\n    }\n\n    const clone = Array.isArray(obj) ? [] : {};\n    // @ts-expect-error\n    Object.entries(obj).forEach(([key, value]) => (clone[key] = deepClone(value)));\n\n    return clone as T;\n}\n", "import 'reflect-metadata';\n\nimport { deepClone } from './helpers.js';\n\nexport const META_PREFIX: string = 'moleculer:decorators';\n\nfunction isKey(key: string, scope: string = '') {\n    return typeof key === 'string' && key.startsWith(`${META_PREFIX}${scope}:`);\n}\n\nfunction prefixKey(key: string, scope: string = '') {\n    if (!isKey(key, scope)) {\n        return `${META_PREFIX}${scope}:${key}`;\n    }\n\n    return key;\n}\n\nexport function getMetadataKeys(target: any, scope: string = '') {\n    const keys = Reflect.getMetadataKeys(target) || [];\n\n    const metadataKeys: { key: string; metadata: any }[] = [];\n    keys.forEach((key) => {\n        if (isKey(key, scope)) {\n            metadataKeys.push({\n                key: key.replace(new RegExp(`^${META_PREFIX}${scope}:`), ''),\n                metadata: getMetadata(target, key, scope),\n            });\n        }\n    });\n\n    return metadataKeys;\n}\n\nexport function getMetadata(target: any, key: string, scope: string = '') {\n    return deepClone(Reflect.getMetadata(prefixKey(key, scope), target));\n}\n\nexport function setMetadata(target: any, key: string, value: any, scope: string = '') {\n    Reflect.defineMetadata(prefixKey(key, scope), value, target);\n}\n\nexport function removeMetadata(target: any, key: string, scope: string = '') {\n    return Reflect.deleteMetadata(prefixKey(key, scope), target);\n}\n\nexport function getOwnMetadata(target: any, key: string, scope: string = '') {\n    return deepClone(Reflect.getOwnMetadata(prefixKey(key, scope), target));\n}\n\nexport function setCache(target: any, key: string, value: any) {\n    setMetadata(target, key, value, 'cache');\n}\n\nexport function getCache(target: any, key: string) {\n    return getMetadata(target, key, 'cache');\n}\n\nexport function getTypes(target: any, key: string | symbol) {\n    return Reflect.getMetadata('design:type', target, key);\n}\n", "import { ActionSchema, Context } from 'moleculer';\n\nimport { PartialRequired, getMetadata, setMetadata } from '../utils/index.js';\n\nexport type ActionOptions = PartialRequired<Exclude<ActionSchema, 'handler'>, 'name'>;\n\ntype MethodDecorator<T> = (\n    target: Object,\n    propertyKey: string | symbol,\n    descriptor: TypedPropertyDescriptor<T>,\n) => TypedPropertyDescriptor<T> | void;\n\nexport function Action<P = {}, T = (ctx: Context<P>) => void>(\n    options?: ActionOptions,\n): MethodDecorator<T> {\n    return (target, propertyKey, descriptor) => {\n        const handler = descriptor.value;\n\n        if (!handler || typeof handler !== 'function') {\n            throw new TypeError('An action must be a function');\n        }\n\n        const name = propertyKey.toString();\n        const actions = getMetadata(target, 'actions', 'service') || {};\n        actions[name] = Object.assign({}, { handler, name, visibility: 'public' }, options);\n\n        setMetadata(target, 'actions', actions, 'service');\n        return descriptor;\n    };\n}\n", "import { EventSchema } from 'moleculer';\n\nimport { PartialRequired, getMetadata, setMetadata } from '../utils/index.js';\n\nexport type EventOptions = PartialRequired<Exclude<EventSchema, 'handler'>, 'name'>;\n\nexport type LifeCycleEventNames = 'created' | 'started' | 'stopped';\n\nexport function Event(options?: EventSchema): MethodDecorator {\n    return <T>(\n        target: Object,\n        propertyKey: string | symbol,\n        descriptor: TypedPropertyDescriptor<T>,\n    ) => {\n        const handler = descriptor.value;\n\n        if (!handler || typeof handler !== 'function') {\n            throw new TypeError('An event handler must be a function');\n        }\n\n        const name = propertyKey.toString();\n        const events = getMetadata(target, 'events', 'service') || {};\n\n        events[name] = Object.assign({}, { handler, name }, options);\n\n        setMetadata(target, 'events', events, 'service');\n        return descriptor;\n    };\n}\n\nexport function createLifeCycleEvent(name: LifeCycleEventNames): MethodDecorator {\n    if (!name) {\n        throw new ReferenceError('Lifecycle event name required');\n    }\n\n    return <T>(\n        target: Object,\n        _propertyKey: string | symbol,\n        descriptor: TypedPropertyDescriptor<T>,\n    ) => {\n        const handler = descriptor.value;\n\n        if (!handler || typeof handler !== 'function') {\n            throw new TypeError('An lifecycle event handler must be a function');\n        }\n\n        setMetadata(target, name, handler, 'service');\n        return descriptor;\n    };\n}\n\nexport const Created = createLifeCycleEvent('created') as MethodDecorator;\nexport const Started = createLifeCycleEvent('started') as MethodDecorator;\nexport const Stopped = createLifeCycleEvent('stopped') as MethodDecorator;\n", "import { getMetadata, setMetadata } from '../utils/index.js';\n\nconst MoleculerMethod = <T>(\n    target: Object,\n    propertyKey: string | symbol,\n    descriptor: TypedPropertyDescriptor<T>,\n) => {\n    const handler = descriptor.value;\n\n    if (!handler || typeof handler !== 'function') {\n        throw new TypeError('A method must be a function');\n    }\n\n    const name = propertyKey.toString();\n    const methods = getMetadata(target, 'methods', 'service') || {};\n    methods[name] = { handler };\n\n    setMetadata(target, 'methods', methods, 'service');\n    return descriptor;\n};\n\nexport const Method = MoleculerMethod as MethodDecorator;\n", "import {\n    Service as MoleculerService,\n    ServiceHooks,\n    ServiceSchema,\n    ServiceSettingSchema,\n} from 'moleculer';\n\nimport { getMetadata, getMetadataKeys, setMetadata } from '../utils/index.js';\n\n/* -------------------------------------------- types ------------------------------------------- */\n\nexport interface ServiceDependency {\n    name: string;\n    version?: string | number;\n}\n\nexport interface ServiceOptions<S> {\n    name?: string;\n    version?: string | number;\n    settings?: S & ServiceSettingSchema;\n    dependencies?: string | ServiceDependency | Array<string | ServiceDependency>;\n    metadata?: any;\n    mixins?: Array<Partial<ServiceSchema> | ServiceConstructor<any>>;\n    hooks?: ServiceHooks;\n\n    [name: string]: any;\n}\n\nexport interface ServiceConstructor<S> {\n    new (...args: any[]): MoleculerService<S>;\n}\n\nexport type ServiceDecorator = <S, T extends ServiceConstructor<S>>(constructor: T) => T;\n\n/* ------------------------------------------- methods ------------------------------------------ */\n\nexport function isServiceClass<S>(constructor: any): constructor is ServiceConstructor<S> {\n    return typeof constructor === 'function' && MoleculerService.isPrototypeOf(constructor);\n}\n\nexport function getServiceInnerSchema<S>(\n    constructor: ServiceConstructor<S>,\n): Partial<ServiceSchema<S>> {\n    if (!isServiceClass(constructor)) {\n        throw TypeError('Class must extend Service');\n    }\n\n    const serviceSchema: Partial<ServiceSchema<S>> = {};\n\n    const keys = getMetadataKeys(constructor.prototype, 'service');\n    keys.forEach(({ key, metadata }) => (serviceSchema[key] = metadata));\n\n    return serviceSchema;\n}\n\nexport function getServiceSchema<S>(constructor: ServiceConstructor<S>): ServiceSchema<S> {\n    if (!isServiceClass(constructor)) {\n        throw TypeError('Class must extend Service');\n    }\n\n    return (\n        getMetadata(constructor.prototype, 'schema', 'service') ||\n        getServiceInnerSchema(constructor)\n    );\n}\n\nexport function convertServiceMixins<S>(schema: ServiceSchema<S>) {\n    if (!schema.mixins) return;\n\n    const convertMixins = <S>(mixins: Array<Partial<ServiceSchema<S>> | ServiceConstructor<S>>) => {\n        return mixins.map((mixin) => {\n            const convertedMixin = isServiceClass<S>(mixin) ? getServiceSchema<S>(mixin) : mixin;\n            if (convertedMixin.mixins) {\n                convertedMixin.mixins = convertMixins(convertedMixin.mixins);\n            }\n            return convertedMixin;\n        });\n    };\n\n    schema.mixins = convertMixins(schema.mixins);\n}\n\ntype InstanceGenericType<T extends abstract new (...args: any) => MoleculerService<any>> =\n    T extends abstract new (...args: any) => MoleculerService<infer R> ? R : any;\n\nexport function Service<T extends ServiceConstructor<any>, S extends InstanceGenericType<T>>(\n    options: ServiceOptions<S> = {},\n) {\n    return (constructor: T): T => {\n        if (!isServiceClass<S>(constructor)) {\n            throw TypeError('Class must extend Service');\n        }\n\n        let schema: ServiceSchema<S> = getMetadata(constructor.prototype, 'schema', 'service');\n\n        if (!schema) {\n            // prepare defaults\n            const defaults = {\n                name: constructor.name,\n                ...options,\n            };\n\n            // get schema\n            schema = {\n                ...defaults,\n                ...getServiceInnerSchema(constructor),\n            };\n\n            // convert mixins\n            convertServiceMixins(schema);\n\n            setMetadata(constructor.prototype, 'schema', schema, 'service');\n        }\n\n        return class extends constructor {\n            constructor(...args: any[]) {\n                super(...args);\n                this.parseServiceSchema(schema);\n            }\n        };\n    };\n}\n", "import { getMetadata, setMetadata } from '../../utils/index.js';\n\nexport type ChanneltOptions = Partial<Exclude<any, 'handler'>> & { name: string };\n\nexport function Channel(options?: ChanneltOptions): MethodDecorator {\n    return <T>(\n        target: Object,\n        propertyKey: string | symbol,\n        descriptor: TypedPropertyDescriptor<T>,\n    ) => {\n        const handler = descriptor.value;\n\n        if (!handler || typeof handler !== 'function') {\n            throw new TypeError('An event handler must be a function');\n        }\n\n        const name = propertyKey.toString();\n        const channels = getMetadata(target, 'channels', 'service') || {};\n\n        channels[name] = Object.assign({}, { handler, name }, options);\n\n        setMetadata(target, 'channels', channels, 'service');\n        return descriptor;\n    };\n}\n"],
  "mappings": "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",
  "names": ["deepClone", "obj", "clonedSet", "value", "clonedMap", "key", "clone", "META_PREFIX", "isKey", "key", "scope", "prefixKey", "getMetadataKeys", "target", "keys", "metadataKeys", "getMetadata", "deepClone", "setMetadata", "value", "Action", "options", "target", "propertyKey", "descriptor", "handler", "name", "actions", "getMetadata", "setMetadata", "Event", "options", "target", "propertyKey", "descriptor", "handler", "name", "events", "getMetadata", "setMetadata", "createLifeCycleEvent", "_propertyKey", "Created", "Started", "Stopped", "MoleculerMethod", "target", "propertyKey", "descriptor", "handler", "name", "methods", "getMetadata", "setMetadata", "Method", "MoleculerService", "isServiceClass", "constructor", "MoleculerService", "getServiceInnerSchema", "serviceSchema", "getMetadataKeys", "key", "metadata", "getServiceSchema", "getMetadata", "convertServiceMixins", "schema", "convertMixins", "mixins", "mixin", "convertedMixin", "Service", "options", "setMetadata", "args", "Channel", "options", "target", "propertyKey", "descriptor", "handler", "name", "channels", "getMetadata", "setMetadata"]
}
